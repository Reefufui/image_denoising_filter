#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 16
#define PATCH_WINDOW   3

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

struct Pixel
{
    vec4 value;
};

layout(push_constant) uniform u_params_t
{
    int width;
    int height;

} u_params;

layout(std140, binding = 0) buffer buf
{
    Pixel imageData[];
};

layout (binding = 1) uniform sampler2D u_inputTex;

vec4 nlmDenoice(ivec2 a_texCoord)
{
    if ( (a_texCoord.x - PATCH_WINDOW) < 0 
        || (a_texCoord.y - PATCH_WINDOW) < 0
        || (a_texCoord.x + PATCH_WINDOW) > u_params.height
        || (a_texCoord.y + PATCH_WINDOW) > u_params.width)
    {
        return texelFetch(u_inputTex, a_texCoord, 0);
    }

    const float filteringParameter = 1.f;
    float normWeight = 0.f;
    vec4 weightColor = vec4(0.);

    // Loop through all pixels of an image
    for (int y = PATCH_WINDOW; y < u_params.height - PATCH_WINDOW; y += 17)
    {
        for (int x = PATCH_WINDOW; x < u_params.width - PATCH_WINDOW; x += 17)
        {
            vec4  curColor = texelFetch(u_inputTex, ivec2(x, y), 0);
            float colorDistance = 0.0f;

            for (int j = - PATCH_WINDOW; j < PATCH_WINDOW; ++j)
            {
                for (int i = - PATCH_WINDOW; i < PATCH_WINDOW; ++i)
                {
                    vec4 texColorPatch = texelFetch(u_inputTex, ivec2(i, j) + a_texCoord, 0);
                    vec4 curColorPatch = texelFetch(u_inputTex, ivec2(i + x, j + y), 0);

                    colorDistance += pow(texColorPatch.x - curColorPatch.x, 2.f)
                                + pow(texColorPatch.y - curColorPatch.y, 2.f)
                                + pow(texColorPatch.z - curColorPatch.z, 2.f);
                }
            }
            float weight = exp(- colorDistance / pow(filteringParameter, 2.f));
            weightColor += curColor * weight;
            normWeight += weight;
        }
    }

    return weightColor / normWeight;
}

void main()
{
    if (gl_GlobalInvocationID.x >= u_params.width || gl_GlobalInvocationID.y >= u_params.height)
        return;

    ivec2 texCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    imageData[u_params.width * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x].value = nlmDenoice(texCoord);
}
